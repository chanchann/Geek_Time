## 如何来发起连接关闭

重点关注的是“半连接”状态。

![tcp3](https://static001.geekbang.org/resource/image/65/29/65cef2c44480910871a0b66cac1d5529.png)


![tcp4](https://static001.geekbang.org/resource/image/f3/e1/f34823ce42a49e4eadaf642a75d14de1.png)

TCP 是双向的，这里说的方向，指的是数据流的写入 - 读出的方向。

在绝大数情况下，TCP 连接都是先关闭一个方向，此时另外一个方向还是可以正常进行数据传输。

## 优雅和粗暴关闭的场景

## close 

```cpp
int close(int sockfd)
```

**套接字引用计数**

这个函数会对套接字引用计数减一，一旦发现套接字引用计数到 0，就会对套接字进行彻底释放，并且会关闭 TCP 两个方向的数据流。

关闭两个方向的数据流

1. 在输入方向，系统内核会将该套接字设置为不可读，任何读操作都会返回异常。

2. 在输出方向，系统内核尝试将发送缓冲区的数据发送给对端，并最后向对端发送一个 FIN 报文，接下来如果再对该套接字进行写操作会返回异常。

如果对端没有检测到套接字已关闭，还继续发送报文，就会收到一个 RST 报文，告诉对端：“Hi, 我已经关闭了，别再给我发数据了。”

close 函数并不能帮助我们关闭连接的一个方向，所以引出shutdown

## shutdown

```cpp
int shutdown(int sockfd, int howto)
```

SHUT_RD(0) : 关闭读，丢弃接收缓冲区数据，新数据悄悄丢弃，还回发ACK

SHUT_WR(1) ：关闭写，套接字上发送缓冲区已有的数据将被立即发送出去，并发送一个 FIN 报文给对端

SHUT_RDWR(2) : SHUT_RD 和 SHUT_WR 操作各一次

## SHUT_RDWR vs close 

1. close 会关闭连接，并释放所有连接对应的资源，而 shutdown 并不会释放掉套接字和所有的资源。 

Q : shutdown 何时释放如何释放？

2. 第二个差别：close 存在引用计数的概念，并不一定导致该套接字不可用；shutdown 则不管引用计数，直接使得该套接字不可用，如果有别的进程企图使用该套接字，将会受到影响。

3. 第三个差别：close 的引用计数导致不一定会发出 FIN 结束报文，而 shutdown 则总是会发出 FIN 结束报文，这在我们打算关闭连接通知对端的时候，是非常重要的。

## 差别实验