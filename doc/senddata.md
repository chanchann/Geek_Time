## 使用套接字进行读写

连接建立的根本目的是为了数据的收发

## 发送数据

```cpp
ssize_t write (int socketfd, const void *buffer, size_t size)
ssize_t send (int socketfd, const void *buffer, size_t size, int flags)
ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags)
```

使用场景

1. 第一个函数是常见的文件写函数，如果把 socketfd 换成文件描述符，就是普通的文件写入。

2. 如果想指定选项，发送带外数据，就需要使用第二个带 flag 的函数。

(所谓带外数据，是一种基于 TCP 协议的紧急数据，用于客户端 - 服务器在特定场景下的紧急处理。)

3. 如果想指定多重缓冲区传输数据，就需要使用第三个函数，以结构体 msghdr 的方式发送数据。

### 在套接字描述符上调用 write 函 VS 在普通文件描述符上调用 write 函数

1. 对于普通文件描述符而言，一个文件描述符代表了打开的一个文件句柄，通过调用 write 函数，操作系统内核帮我们不断地往文件系统中写入字节流。注意，写入的字节流大小通常和输入参数 size 的值是相同的，否则表示出错。

2. 对于套接字描述符而言，它代表了一个双向连接，在套接字描述符上调用 write 写入的字节数有可能比请求的数量少(内核帮我们做了很多事)，这在普通文件描述符情况下是不正常的。 

### 发送缓冲区

TCP 连接成功建立后，操作系统内核会为每一个连接创建配套的基础设施，比如发送缓冲区

发送缓冲区的大小可以通过套接字选项来改变，当我们的应用程序调用 write 函数时，实际所做的事情是把数据从应用程序中拷贝到操作系统内核的发送缓冲区中，并不一定是把数据通过套接字写出去。

几种情况:

1. 操作系统内核的发送缓冲区足够大，可以直接容纳这份数据,我们的程序从 write 调用中退出，返回写入的字节数就是应用程序的数据大小。

2. 操作系统内核的发送缓冲区是够大了，不过还有数据没有发送完

3. 操作系统内核的发送缓冲区不足以容纳应用程序数据.

2,3 : 报错？还是直接返回？操作系统内核并不会返回，也不会报错，而是应用程序被阻塞，也就是说应用程序在 write 函数调用处停留，不直接返回。术语“挂起”也表达了相同的意思，不过“挂起”是从操作系统内核角度来说的。

大部分 UNIX 系统的做法是一直等到可以把应用程序数据完全放到操作系统内核的发送缓冲区中，再从系统调用中返回

## 读取数据

```cpp
ssize_t read (int socketfd, void *buffer, size_t size)
```

如果返回值为 0，表示 EOF（end-of-file），这在网络中表示对端发送了 FIN 包，要处理断连的情况；