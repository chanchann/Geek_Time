

## TIME_WAIT

https://zhuanlan.zhihu.com/p/73726369

https://time.geekbang.org/column/article/125806

### 1.产生问题

应用服务需要通过发起 TCP 连接对外提供服务。每个连接会占用一个本地端口，当在高并发的情况下，TIME_WAIT 状态的连接过多，多到把本机可用的端口耗尽，应用服务对外表现的症状，就是不能正常工作了

### 2.为什么产生

TCP 四次挥手 -- 分析

![tcp4](https://static001.geekbang.org/resource/image/f3/e1/f34823ce42a49e4eadaf642a75d14de1.png)

TIME_WAIT 停留持续时间是固定的，2MSL

**只有发起连接终止的一方会进入 TIME_WAIT 状态。**

### 3.为什么不直接进入 CLOSED 状态，而要停留在 TIME_WAIT 这个状态

1. 这样做是为了确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。

主机 1 的 ACK 报文没有传输成功，那么主机 2 就会重新发送 FIN 报文,如果主机 1 没有维护 TIME_WAIT 状态，而直接进入 CLOSED 状态，它就失去了当前状态的上下文，只能回复一个 RST 操作，从而导致被动关闭方出现错误。

2. 连接“化身”和报文迷走有关系，为了让旧连接的重复分节在网络中自然消失。

一个连接关闭后，另一个连接和它ip端口一模一样，成了它的化身，如果没有2msl，有些报文因为链路问题走得慢，就不知道是它发的还是化身发的报文，而2msl后过了最长生命周期的两倍后，即到达再回来的最长时间，上一个连接的报文会全部消失，以后的报文都是化身产生的了。

**2MSL 的时间是从主机 1 接收到 FIN 后发送 ACK 开始计时的，会重新计时**

### TIME_WAIT 的危害

1. 内存资源占用，可忽略

2. 对端口资源的占用

## 解决办法

新的 TCP 选项，两个 4 字节的时间戳字段，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。由于引入了时间戳，我们在前面提到的 2MSL 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。

## Questions